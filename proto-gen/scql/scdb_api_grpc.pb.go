// Copyright 2023 Ant Group Co., Ltd.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.20.3
// source: api/scdb_api.proto

package scql

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SCDBService_Submit_FullMethodName       = "/scql.pb.SCDBService/Submit"
	SCDBService_Fetch_FullMethodName        = "/scql.pb.SCDBService/Fetch"
	SCDBService_SubmitAndGet_FullMethodName = "/scql.pb.SCDBService/SubmitAndGet"
)

// SCDBServiceClient is the client API for SCDBService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// SCDBService provides a collection of APIs,
// that client-user can connect to the SCQL system, execute queries and fetch
// results.
type SCDBServiceClient interface {
	// Submit
	//
	// Asynchronous query interface.
	// Submit the query (DDL/DCL/DQL) to SCQL, and return immediately.
	// It will allocate a new `scdb_session_id` for the query, and set it in
	// response.
	Submit(ctx context.Context, in *SCDBQueryRequest, opts ...grpc.CallOption) (*SCDBSubmitResponse, error)
	// Fetch
	//
	// Fetch the result of the query submitted asynchronously.
	// It will return `NOT_READY` status code if the query is still running.
	Fetch(ctx context.Context, in *SCDBFetchRequest, opts ...grpc.CallOption) (*SCDBQueryResultResponse, error)
	// SubmitAndGet
	//
	// The synchronous query interface allows users to submit a query,
	// wait for it to finish, and get the query result in one RPC.
	// This interface is suitable for executing fast queries,
	// such as DDL, DCL, and simple DQL. However,
	// if the query takes a long time to run, it may result in a timeout.
	// Therefore, it is recommended to use the synchronous query API to run
	// complex queries.
	SubmitAndGet(ctx context.Context, in *SCDBQueryRequest, opts ...grpc.CallOption) (*SCDBQueryResultResponse, error)
}

type sCDBServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSCDBServiceClient(cc grpc.ClientConnInterface) SCDBServiceClient {
	return &sCDBServiceClient{cc}
}

func (c *sCDBServiceClient) Submit(ctx context.Context, in *SCDBQueryRequest, opts ...grpc.CallOption) (*SCDBSubmitResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SCDBSubmitResponse)
	err := c.cc.Invoke(ctx, SCDBService_Submit_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCDBServiceClient) Fetch(ctx context.Context, in *SCDBFetchRequest, opts ...grpc.CallOption) (*SCDBQueryResultResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SCDBQueryResultResponse)
	err := c.cc.Invoke(ctx, SCDBService_Fetch_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCDBServiceClient) SubmitAndGet(ctx context.Context, in *SCDBQueryRequest, opts ...grpc.CallOption) (*SCDBQueryResultResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SCDBQueryResultResponse)
	err := c.cc.Invoke(ctx, SCDBService_SubmitAndGet_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SCDBServiceServer is the server API for SCDBService service.
// All implementations must embed UnimplementedSCDBServiceServer
// for forward compatibility.
//
// SCDBService provides a collection of APIs,
// that client-user can connect to the SCQL system, execute queries and fetch
// results.
type SCDBServiceServer interface {
	// Submit
	//
	// Asynchronous query interface.
	// Submit the query (DDL/DCL/DQL) to SCQL, and return immediately.
	// It will allocate a new `scdb_session_id` for the query, and set it in
	// response.
	Submit(context.Context, *SCDBQueryRequest) (*SCDBSubmitResponse, error)
	// Fetch
	//
	// Fetch the result of the query submitted asynchronously.
	// It will return `NOT_READY` status code if the query is still running.
	Fetch(context.Context, *SCDBFetchRequest) (*SCDBQueryResultResponse, error)
	// SubmitAndGet
	//
	// The synchronous query interface allows users to submit a query,
	// wait for it to finish, and get the query result in one RPC.
	// This interface is suitable for executing fast queries,
	// such as DDL, DCL, and simple DQL. However,
	// if the query takes a long time to run, it may result in a timeout.
	// Therefore, it is recommended to use the synchronous query API to run
	// complex queries.
	SubmitAndGet(context.Context, *SCDBQueryRequest) (*SCDBQueryResultResponse, error)
	mustEmbedUnimplementedSCDBServiceServer()
}

// UnimplementedSCDBServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSCDBServiceServer struct{}

func (UnimplementedSCDBServiceServer) Submit(context.Context, *SCDBQueryRequest) (*SCDBSubmitResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Submit not implemented")
}
func (UnimplementedSCDBServiceServer) Fetch(context.Context, *SCDBFetchRequest) (*SCDBQueryResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Fetch not implemented")
}
func (UnimplementedSCDBServiceServer) SubmitAndGet(context.Context, *SCDBQueryRequest) (*SCDBQueryResultResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitAndGet not implemented")
}
func (UnimplementedSCDBServiceServer) mustEmbedUnimplementedSCDBServiceServer() {}
func (UnimplementedSCDBServiceServer) testEmbeddedByValue()                     {}

// UnsafeSCDBServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SCDBServiceServer will
// result in compilation errors.
type UnsafeSCDBServiceServer interface {
	mustEmbedUnimplementedSCDBServiceServer()
}

func RegisterSCDBServiceServer(s grpc.ServiceRegistrar, srv SCDBServiceServer) {
	// If the following call pancis, it indicates UnimplementedSCDBServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SCDBService_ServiceDesc, srv)
}

func _SCDBService_Submit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SCDBQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCDBServiceServer).Submit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SCDBService_Submit_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCDBServiceServer).Submit(ctx, req.(*SCDBQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCDBService_Fetch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SCDBFetchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCDBServiceServer).Fetch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SCDBService_Fetch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCDBServiceServer).Fetch(ctx, req.(*SCDBFetchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCDBService_SubmitAndGet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SCDBQueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCDBServiceServer).SubmitAndGet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SCDBService_SubmitAndGet_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCDBServiceServer).SubmitAndGet(ctx, req.(*SCDBQueryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SCDBService_ServiceDesc is the grpc.ServiceDesc for SCDBService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SCDBService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "scql.pb.SCDBService",
	HandlerType: (*SCDBServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Submit",
			Handler:    _SCDBService_Submit_Handler,
		},
		{
			MethodName: "Fetch",
			Handler:    _SCDBService_Fetch_Handler,
		},
		{
			MethodName: "SubmitAndGet",
			Handler:    _SCDBService_SubmitAndGet_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/scdb_api.proto",
}

const (
	SCDBQueryResultCallback_ReportQueryResult_FullMethodName = "/scql.pb.SCDBQueryResultCallback/ReportQueryResult"
)

// SCDBQueryResultCallbackClient is the client API for SCDBQueryResultCallback service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// SCDBQueryResultCallback defines an API that SCQL could use it to notify the
// caller when the query result is ready, either because it has finished
// successfully or an error has occurred.
type SCDBQueryResultCallbackClient interface {
	// ReportQueryResult reports the query result once the query job done.
	ReportQueryResult(ctx context.Context, in *SCDBQueryResultResponse, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type sCDBQueryResultCallbackClient struct {
	cc grpc.ClientConnInterface
}

func NewSCDBQueryResultCallbackClient(cc grpc.ClientConnInterface) SCDBQueryResultCallbackClient {
	return &sCDBQueryResultCallbackClient{cc}
}

func (c *sCDBQueryResultCallbackClient) ReportQueryResult(ctx context.Context, in *SCDBQueryResultResponse, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, SCDBQueryResultCallback_ReportQueryResult_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SCDBQueryResultCallbackServer is the server API for SCDBQueryResultCallback service.
// All implementations must embed UnimplementedSCDBQueryResultCallbackServer
// for forward compatibility.
//
// SCDBQueryResultCallback defines an API that SCQL could use it to notify the
// caller when the query result is ready, either because it has finished
// successfully or an error has occurred.
type SCDBQueryResultCallbackServer interface {
	// ReportQueryResult reports the query result once the query job done.
	ReportQueryResult(context.Context, *SCDBQueryResultResponse) (*emptypb.Empty, error)
	mustEmbedUnimplementedSCDBQueryResultCallbackServer()
}

// UnimplementedSCDBQueryResultCallbackServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSCDBQueryResultCallbackServer struct{}

func (UnimplementedSCDBQueryResultCallbackServer) ReportQueryResult(context.Context, *SCDBQueryResultResponse) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportQueryResult not implemented")
}
func (UnimplementedSCDBQueryResultCallbackServer) mustEmbedUnimplementedSCDBQueryResultCallbackServer() {
}
func (UnimplementedSCDBQueryResultCallbackServer) testEmbeddedByValue() {}

// UnsafeSCDBQueryResultCallbackServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SCDBQueryResultCallbackServer will
// result in compilation errors.
type UnsafeSCDBQueryResultCallbackServer interface {
	mustEmbedUnimplementedSCDBQueryResultCallbackServer()
}

func RegisterSCDBQueryResultCallbackServer(s grpc.ServiceRegistrar, srv SCDBQueryResultCallbackServer) {
	// If the following call pancis, it indicates UnimplementedSCDBQueryResultCallbackServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SCDBQueryResultCallback_ServiceDesc, srv)
}

func _SCDBQueryResultCallback_ReportQueryResult_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SCDBQueryResultResponse)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCDBQueryResultCallbackServer).ReportQueryResult(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SCDBQueryResultCallback_ReportQueryResult_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCDBQueryResultCallbackServer).ReportQueryResult(ctx, req.(*SCDBQueryResultResponse))
	}
	return interceptor(ctx, in, info, handler)
}

// SCDBQueryResultCallback_ServiceDesc is the grpc.ServiceDesc for SCDBQueryResultCallback service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SCDBQueryResultCallback_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "scql.pb.SCDBQueryResultCallback",
	HandlerType: (*SCDBQueryResultCallbackServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReportQueryResult",
			Handler:    _SCDBQueryResultCallback_ReportQueryResult_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/scdb_api.proto",
}
